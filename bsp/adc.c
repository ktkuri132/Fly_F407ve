#include "driver.h"
#include "df_adc.h"

extern At adc1;

/*******************************************************************************
 * STM32F407 ADC1驱动程序
 *
 * 硬件配置:
 *   - GPIO引脚: PB1
 *   - ADC通道: ADC1_IN9 / ADC2_IN9 (此处使用ADC1)
 *   - 转换模式: 连续转换模式 (Continuous Conversion Mode)
 *   - 中断: 不使用中断，采用轮询方式读取
 *   - 分辨率: 12位 (0-4095)
 *   - 采样时间: 480个ADC时钟周期 (最高精度)
 *
 * ADC通道与GPIO映射关系 (STM32F407):
 *   - ADC123_IN9: PB1
 *   - ADC12表示该通道同时属于ADC1和ADC2
 ******************************************************************************/

/* ADC通道定义 */
#define ADC_CHANNEL_9 9    /* PB1对应的ADC通道号 */
#define ADC_SAMPLE_480 0x7 /* 480个周期采样时间 (最高精度) */

/**
 * @brief  ADC1初始化函数
 * @note   配置PB1为模拟输入，ADC1通道9，连续转换模式
 * @param  arg: 设备参数 (未使用)
 * @retval 0: 成功
 */
int adc1_init(dev_arg_t arg)
{
    (void)arg; /* 防止编译器警告未使用参数 */

    /***************************************************************************
     * 步骤1: 使能时钟
     * - ADC1挂载在APB2总线上，需要使能APB2上的ADC1时钟
     * - PB1属于GPIOB，需要使能AHB1总线上的GPIOB时钟
     ***************************************************************************/
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;  /* 使能ADC1时钟 */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN; /* 使能GPIOB时钟 */

    /***************************************************************************
     * 步骤2: 配置GPIO - PB1为模拟输入模式
     * - MODER寄存器每2位控制一个引脚
     * - PB1对应MODER[3:2]
     * - 模拟模式值为0x3 (11b)
     * - 模拟输入模式下，不需要配置上下拉电阻
     ***************************************************************************/
    GPIOB->MODER &= ~(0x3 << (1 * 2)); /* 先清除PB1的MODER位 */
    GPIOB->MODER |= (0x3 << (1 * 2));  /* 设置PB1为模拟模式 (0x3 = 11b) */

    /***************************************************************************
     * 步骤3: 配置ADC1
     ***************************************************************************/

    /* 3.1 关闭ADC以便进行配置 (ADON = 0) */
    ADC1->CR2 &= ~ADC_CR2_ADON;

    /* 3.2 配置ADC分辨率为12位 (RES[1:0] = 00)
     * - 00: 12位分辨率 (15个ADC时钟周期)
     * - 01: 10位分辨率 (13个ADC时钟周期)
     * - 10: 8位分辨率  (11个ADC时钟周期)
     * - 11: 6位分辨率  (9个ADC时钟周期)
     */
    ADC1->CR1 &= ~ADC_CR1_RES; /* 清除RES位，设置12位分辨率 */

    /* 3.3 配置为连续转换模式 (CONT = 1)
     * - CONT = 0: 单次转换模式，每次触发只转换一次
     * - CONT = 1: 连续转换模式，转换完成后自动开始下一次转换
     * 连续转换模式下，只需触发一次，ADC会持续不断地进行转换
     */
    ADC1->CR2 |= ADC_CR2_CONT; /* 使能连续转换模式 */

    /* 3.4 配置数据对齐方式为右对齐 (ALIGN = 0)
     * - ALIGN = 0: 右对齐 (常用)
     * - ALIGN = 1: 左对齐
     */
    ADC1->CR2 &= ~ADC_CR2_ALIGN; /* 右对齐 */

    /* 3.5 配置ADC通道9的采样时间
     * - SMPR1寄存器控制通道10-18
     * - SMPR2寄存器控制通道0-9
     * - 通道9在SMPR2中，位置为SMP9[2:0]，即bit[29:27]
     * - 采样时间值: 0x7 = 480个周期 (最高精度，适合高阻抗信号源)
     *
     * 采样时间选择说明:
     *   000: 3个周期    001: 15个周期   010: 28个周期   011: 56个周期
     *   100: 84个周期   101: 112个周期  110: 144个周期  111: 480个周期
     */
    ADC1->SMPR2 &= ~(0x7 << (ADC_CHANNEL_9 * 3));           /* 清除通道9采样时间位 */
    ADC1->SMPR2 |= (ADC_SAMPLE_480 << (ADC_CHANNEL_9 * 3)); /* 设置480周期采样 */

    /* 3.6 配置规则通道转换序列
     * - SQR1的L[3:0]位 (bit[23:20]) 设置转换序列长度
     * - L = 0 表示1次转换，L = 1 表示2次转换，以此类推
     * - SQR3的SQ1[4:0]位 (bit[4:0]) 设置第1个转换的通道号
     */
    ADC1->SQR1 &= ~ADC_SQR1_L;  /* 清除L位，设置转换序列长度为1 */
    ADC1->SQR3 = ADC_CHANNEL_9; /* 第1个转换序列设置为通道9 */

    /***************************************************************************
     * 步骤4: 启动ADC
     * - 设置ADON位为1，打开ADC电源
     * - 注意: 首次设置ADON后需等待稳定时间 (约1us)
     ***************************************************************************/
    ADC1->CR2 |= ADC_CR2_ADON; /* 使能ADC1 */

    /* 更新初始化标志 */
    adc1.ADC_Init_Flag = true;

    return 0;
}

/**
 * @brief  启动ADC1转换
 * @note   在连续转换模式下，只需触发一次，ADC会持续转换
 * @param  arg: 设备参数 (未使用)
 * @retval 0: 成功
 */
int adc1_enable(dev_arg_t arg)
{
    (void)arg;

    /* 软件触发启动规则通道转换
     * - SWSTART位为1时触发转换
     * - 在连续模式下，此触发后ADC会持续进行转换
     * - 该位由硬件自动清零
     */
    ADC1->CR2 |= ADC_CR2_SWSTART;

    return 0;
}

/**
 * @brief  停止并关闭ADC1
 * @note   清除ADON位关闭ADC电源
 * @param  arg: 设备参数 (未使用)
 * @retval 0: 成功
 */
int adc1_disable(dev_arg_t arg)
{
    (void)arg;

    /* 关闭ADC1电源 */
    ADC1->CR2 &= ~ADC_CR2_ADON;

    /* 更新初始化标志 */
    adc1.ADC_Init_Flag = false;

    return 0;
}

/**
 * @brief  获取ADC1转换值 (轮询方式)
 * @note   连续转换模式下，直接读取DR寄存器即可获取最新值
 *         读取DR寄存器会自动清除EOC标志
 * @param  arg: 设备参数，用于返回ADC值
 *              arg.us32 将被设置为ADC转换结果 (0-4095)
 * @retval 0: 成功, -1: ADC未初始化
 */
int adc1_get_value(dev_arg_t arg)
{
    /* 检查ADC是否已初始化 */
    if (!adc1.ADC_Init_Flag)
    {
        return -1;
    }

    /* 等待转换完成 (轮询方式)
     * - EOC (End of Conversion) 位在每次转换完成时被硬件置1
     * - 读取DR寄存器后，EOC位会被自动清除
     * - 在连续转换模式下，EOC位会周期性地被置位
     */
    while (!(ADC1->SR & ADC_SR_EOC))
        ; /* 等待EOC标志置位 */

    /* 读取转换结果
     * - DR寄存器存储12位转换结果 (0-4095)
     * - 右对齐模式下，有效数据在低12位
     * - 读取DR会自动清除EOC标志
     */
    arg.us32 = ADC1->DR;

    return 0;
}

/*******************************************************************************
 * ADC1设备实例
 * 用于设备框架管理
 ******************************************************************************/
At adc1 = {
    .ADC_Init_Flag = false,
    .ADC_Num = 1,
    .ADC_Name = ADC1_NAME,
    .init = adc1_init,
    .deinit = adc1_disable,
    .get_value = adc1_get_value};
